## Architecture

The VOS architecture follows an event-driven, multi-agent design where a single Primary Agent serves as the user's interface while delegating specialized tasks to domain-specific sub-agents. All inter-agent communication occurs asynchronously through RabbitMQ message queues, enabling loose coupling and independent scaling of components. The system employs a notification-based paradigm: user messages, tool results, scheduled events, and agent responses are all represented as typed notifications that agents consume from their dedicated queues. This unified abstraction simplifies the agent processing loop—each agent polls its queue, processes pending notifications through an LLM call, executes any resulting tool calls, and returns to idle. State persistence is handled by PostgreSQL for conversation history and agent metadata, while Weaviate provides vector storage for the semantic memory system. The Primary Agent orchestrates this hierarchy, analyzing user intent and routing requests to Weather, Notes, Calendar, Search, or Browser agents as needed, then synthesizing their responses into coherent replies.

The agent event loop implements a finite state machine with three states: IDLE, THINKING, and EXECUTING_TOOLS. Upon receiving notifications, the agent transitions to THINKING, retrieves relevant conversation history from the database, and invokes proactive memory retrieval to surface contextually useful memories from past interactions. The context—comprising system prompt, message history, current notifications, and retrieved memories—is passed to a Gemini LLM configured for JSON output. The model returns a structured response containing internal reasoning, an optional user-facing action status, and a list of tool calls. The agent then transitions to EXECUTING_TOOLS, dispatching each tool which publishes its result back to the agent's queue as a new notification. After tool execution completes, the proactive memory creator analyzes the conversation for information worth persisting—user preferences, personal facts, or learned procedures—and stores relevant memories to Weaviate. The agent returns to IDLE, ready for the next cycle. This architecture enables complex multi-turn interactions where agents can delegate, wait for results, and maintain coherent context across extended conversations.

The frontend is a cross-platform Flutter application providing a desktop-style virtual operating system interface. It features a modal window system supporting unlimited concurrent applications—including Chat, Notes, Calendar, and Settings—with full drag, resize, minimize, and fullscreen capabilities managed by a centralized ModalManager. Real-time communication with the backend occurs over WebSocket connections that stream agent status updates, action descriptions (e.g., "Searching weather data..."), and new messages as they arrive. The ChatManager maintains optimistic UI updates for sent messages and handles the three-state agent indicator (idle, thinking, executing). Voice mode is supported through dedicated recording and playback services integrated with the chat interface. The architecture separates concerns cleanly: core services handle API communication and state management, the presentation layer manages UI components and routing via GoRouter, and feature modules encapsulate domain-specific functionality. This structure enables responsive interactions where users see immediate feedback while the multi-agent backend processes their requests asynchronously.
