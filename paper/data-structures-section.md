## Data Structures and Technology Stack

The system employs a dual-database architecture optimized for different access patterns. PostgreSQL serves as the relational backbone, storing agent state (status, processing state, message counts), conversation messages (with support for both text and voice input modes), task management (hierarchical tasks with priorities and multi-agent assignment), calendar events (with iCalendar RRULE recurrence), reminders, and notes with full-text search via GIN indexes. The schema enforces referential integrity through foreign key constraints while using ENUM types for type-safe status fields (agent_status, processing_state, task_status). A pending_notifications table guarantees WebSocket message delivery to disconnected clients with automatic retry and cleanup. Weaviate provides the vector store for semantic memory, storing 768-dimensional embeddings generated by Gemini's text-embedding-004 model. The Memory collection schema captures content alongside typed metadata—memory_type (user_preference, user_fact, agent_procedure, etc.), scope (individual or shared), importance and confidence scores, access tracking, and success/failure counts for learning feedback loops.

The backend runs as containerized Python services orchestrated via Docker Compose: FastAPI for the REST/WebSocket API gateway, individual agent containers built on the VOS SDK, RabbitMQ 3 for message brokering, PostgreSQL 15 for relational storage, and Weaviate 1.28 for vector search. LLM inference uses Google's Gemini API—gemini-3-pro-preview for agent reasoning and gemini-2.5-flash-lite for the lightweight memory modules. The Flutter frontend communicates over HTTP REST for commands and WebSocket for real-time streaming of agent status, action descriptions, and messages. Performance optimizations include connection pooling for database access, exponential backoff with jitter for WebSocket reconnection (capped at 30 seconds), message history trimming to bound context window size, and configurable polling intervals for agent notification checks. The notification system batches acknowledgments and uses RabbitMQ's prefetch limits to prevent queue overload during high-throughput scenarios.
